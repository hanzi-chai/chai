# 基础（`pychai.base`）

本节介绍了汉字自动拆分系统中用到的基础组件，这些组件以类的形式体现。

## 画布

**定义**（画布）在二维空间中，我们建立一个平面直角坐标系，使得 $x$ 轴正方向向右、$y$ 轴正方向向下；取其中 $[0, 1]\times [0, 1]$ 的子集称为一个画布。

## 曲线（`base.object.Curve`）

**定义**（曲线）设参数 $t$ 的取值范围是 $[0, 1]$，在该范围内存在两个函数关系 $x(t)$ 和 $y(t)$，它们的值域也包含于 $[0, 1]$。我们记二维向量函数 $\r(t)=(x(t),y(t))$，则当 $t$ 从 $0$ 变化到 $1$ 时，向量函数所代表的平面上的点将绘制出画布上的一条参数曲线，简称为曲线。

出于计算机绘图的便利性，我们采用的一类具体的曲线是 Bezier 曲线，特别地有一次 Bezier 曲线（`base.object.Linear`）和三次 Bezier 曲线（`base.object.Cubic`）。

记 $\P_i$ 是点，则一次 Bezier 曲线的形式为：

$$
\r_1(t)=(1-t)\P_1+t\P_2
$$

它的几何直观是：$t=0$ 时，函数位于 $\P_1$ 处，而 $t=1$ 时，函数位于 $\P_2$ 处，且它是连接 $\P_1,\P_2$ 的一条直线。

三次 Bezier 曲线的形式为：

$$
\r_3(t) = (1-t)^3\P_1 + 3(1-t)^2t\P_2 + 3(1-t)t^2\P_3 + t^3\P_4
$$

## 笔画（`base.object.Stroke`）

**定义**（笔画）笔画是由一段或多段曲线首尾相接组成的几何图形，通常记作 $s$。

这里，「首尾相接」的含义是：上一段曲线参数值取 1 的点恰等于下一段曲线参数值取 0 的点。

根据国标规范，共有 31 种基本笔画，它们用曲线表示的具体方法参见[数据库文档](hanzi-chai.github.io/data/)。

## 汉字（`base.character.Character`）

在一个给定字集内（下面我们都用 GB2312-80 规范所规定的 6763 个汉字作为字集），根据字形、字源等因素，我们可以递降地总结出一个部件集 $C$，将每个汉字

- 要么与部件集中的一个部件对应；
- 要么与「部件集中的部件和指定的 12 个运算符经过有限次运算形成的表达式」相对应。


## 部件（`base.character.Component`）

**定义**（部件）由一个或多个笔画在平面上按一定顺序在给定位置上排布组成的几何图形，通常记作 $c$。

**定义**（运算符）用于表示部件之间二元关系的记号。

本项目共采用 12 个运算符，具体参见[数据库文档](hanzi-chai.github.io/data/)。两个部件经过运算符的运算，就得到了一个**复合体**；复合体可以继续参与运算符的运算，形成更加复杂的复合体。

**定义**（笔画列表）部件 $c$ 所包含的笔画形成的序列 $\operatorname{str}c=(s_1,s_2,\cdots,s_n)$。

**定义**（切片）设部件 $c$ 的笔画列表的长度为 $n$，我们指定一组指标 $i_1,\cdots,i_n$ 使得

$$
1\le i_1\le\cdots\le i_n\le n
$$

那么由第 $i_1,\cdots,i_n$ 个笔画在平面上按此顺序在原有位置上排布组成的几何图形称为一个切片。

我们将切片记为 $p_i=c[i_1,\cdots,i_n]$。显然，它的笔画序列为

$$
\operatorname{str}(c[i_1,\cdots,i_n])=(s_{i_1},\cdots,s_{i_n})
$$

**定义**（部件的拆分）给定部件 $c$，我们称由 $k$ 个 $c$ 的切片构成的 $k$ 元组 $d=(p_1,\cdots,p_k)$ 是一个拆分，当且仅当任两个切片无共同笔画，且所有切片所含的笔画的并集等于汉字 $c$ 的所有笔画。

**定义**（部件的拆分集）给定汉字 $c$，由所有可能拆分 $d$ 构成的集合 $D$。

**定义**（字根）字根同样是由若干笔画在平面上按一定顺序在给定位置上排布组成的几何图形，但这些图形是特别指定的。字根通常记作 $r$。

**定义**（字根集）所有我们指定的字根构成一个集合 $R$。

## 复合体（`base.character.Compound`）

**定义**（选根函数）选根函数 $\mathcal Y$ 具有以下功能：

- 如果汉字能够对应到一个部件，则选根函数作用于该部件的最优拆分，按一定顺序选出若干个字根；
- 如果汉字

## 退化映射（`base.degenerator.Degenerator`）

根据架构，我们首先需要将基本部件拆分为字根。但是，当我们利用上述坐标数据时，我们就面临着一个问题：用户可能希望将不同的字中不同的切片视为同一字根，尽管这些切片的坐标数据不完全一样。例如，「串」中的两个「口」上面的小、下面的大，坐标数据并不相同，但通常用户会将其看作同一字根。如何实现呢？

一种思路是，直接利用上述全部信息，结合人工智能的分类方法进行分类。然而，这将会花费巨大的运算资源（例如，请了解手写数字的神经网络分类模型），于是我们思考的是，上述信息中是否存在某些简单、信息量少的「关键部分」，使得我们仅通过这些关键部分就能有效的区分不同字根？

「拆」为此进行了尝试，将这种对一个切片提取关键信息的函数称为「退化映射」，得到的关键信息称之为「特征」。这样，我们将一个切片经退化映射处理，得到的特征与字根的特征进行比较，如果它的特征与某个字根的特征相等，就可以将它等同于该字根。相反，如果它不与任何字根的特征相等，它就是一个无效切片，不能作为拆分的一部分。

**定义**（退化映射）$\mathcal O$ 将一个切片或一个字根映射为含有较少信息的对象，且满足：

$$
\forall r_1,r_2\in R,r_1\ne r_2\Rightarrow \mathcal O(r_1)\ne \mathcal O(r_2)
$$

即 $\mathcal O$ 在字根集 $R$ 上是单射。

**定义**（部件的可行拆分集）给定汉字 $c$，它的拆分集是 $D$，则它的可行拆分集 $W$ 定义为：

$$
W=\{d|d\in D;\forall p\in d, \exists r\in R\text{ s.t. }\mathcal O(r)=\mathcal O(p)\}
$$

即：对于该拆分中的每一个切片，都存在一个字根使得该字根退化后得到的对象与该切片退化后得到的对象一致。

在实际操作中，我们可能会提取多种不同的关键信息，然后将它们组合起来成为一个字的特征。此时每种信息称为一个「域（field）」，生成这个域的函数称为域函数。

为了便于查询，我们计算所有字根的特征，形成一个以特征索引用户字根的字典；此后，每当我们获得了一个基本部件的切片，我们就能取其特征并在字典中查找，查找得到则为有效切片，否则为无效切片。

## 择优函数（`base.selector.Selector`）

通过上面的流程，我们不难理解，实际上可能的拆分有很多，如何获取我们目标要求的那个，这就是择优函数需要做的事情。

择优函数应该如何表达？我们知道，大多数形码方案会提出几条拆分规则，例如「根少优先」等等。用数学的语言表达，每条规则定义了一个函数，这个函数的作用对象是拆分方案，而其作用结果是给出一个可比较的对象（例如整数或实数），在所有的拆分方案中只有取到最大值或最小值的才能通过此轮筛查，其余将被筛去。

**定义**（择优函数）给定部件 $c$ 和它的可行拆分集 $W$，我们可以给 $W$ 中的每一个拆分指定一个实数，由此确定的映射为 $\mathcal H$。我们进一步要求这个映射是单射。

$$
\mathcal H:W\to\mathbb R
$$

例如，我们得到了 10 个拆分方案，令「根少优先」所定义的函数作用于这 10 个拆分方案时，我们得到其中 3 个方案将字拆为 2 个字根，5 个方案将字拆为 3 个字根，2 个方案将字拆为 4 个字根。那么，我们发现最小值为 2，筛去所有不为 2 个字根的拆分方案，剩余 3 个拆分方案；然后我们再应用其他规则处理剩余的 3 个方案直到唯一为止。

我们形象地将每个这样的函数称为「筛（sieve）」。

以下为伪代码：

如果成功，则每个基本部件都将产生一个最优拆分方案，存储到 `objectChar.bestScheme` 中。

## 拆分的完备性定理

给定一个部件 $c$，我们首先获得它的拆分集 $D$，再根据字根集 $R$ 和退化映射 $\mathcal O$ 确定可行拆分集 $W$。注意：可行拆分集中，每一个拆分中的每一个切片都与恰好一个字根关于退化映射有相同的像，因此每一个拆分都对应着一个「多个字根构成的序列」。

又因为每一个拆分都被指定了一个不同的实数，我们总能找到数最小的一个拆分。这个拆分所对应的字根的序列就是我们的拆分结果。

