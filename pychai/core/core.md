# 核心（`pychai.core`）

## 基类（`core.chai.Chai`）

### 构造函数

读取各数据库、缓存、配置等。

### 接口

公有方法：

- `Chai.getComponentScheme`：生成所有部件拆分，结果保存到 `Chai.COMPONENTS` 的各个部件中；
- `Chai.getCompoundScheme`：生成所有复合体拆分，结果保存到 `Chai.COMPOUNDS` 的各个部件中；
- `Chai.encode`：

以上三个公有方法均有一个同名的私有方法与之对应，但是私有方法的签名是 `(self, character: Character)`。

### 输出函数（`Chai.chai`）

依次调用上述三个方法，并把得到的码表保存到给定路径下。

## 顺序中间类（`core.sequential.Sequential`）

### 幂字典生成（`Sequential.__addPowerDict`）

我们现在讨论：给定一个基本部件，我们可以从其中拆出哪些字根？为了满足不同方案的需求，「拆」采用了比较激进的方案——枚举一个基本部件的所有切片，计算该切片的特征，然后在退化字典中查找它所对应的字根，如果能够找到则标记为有效切片，找不到则标记为无效切片。

那么，一个基本部件最多能形成多少种切片？显然，对于一个 n 笔的字，每个笔画都有取和不取两种状态，因而切片就有 2 的 n 次方种可能性。我们因此可以用 n 个布尔值（即 0 或 1）组成的向量来表达这一切片。例如：

- 设字 c 是含有 5 笔的字，则它的所有切片都可以用一个**含有 5 个布尔值的向量**表达；
- 取字 c 前 2 笔和最后一笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的向量应该是 (1, 1, 0, 0, 1)；
- 取完切片 s 之后，余下部分 r 对应的向量应该是 (0, 0, 1, 1, 0)。


进一步抽象之后，我们很自然地联想到可以使用二进制数来表达切片，这样的好处是我们可以通过位运算来快速处理切片。例如：

- 设字 c 是含有 5 笔的字，则它的所有切片都可以用一个**含有 5 个位的二进制数**表达；
- 取字 c 前 2 笔作为一个切片 s，我们对每个笔画将「取」标记为 1，「不取」标记为 0，那么 s 对应的二进制数应该是 11001，转换为十进制数是 25；
- 取完切片 s 之后，余下部分 r 对应的向量应该是 00111，转换为十进制数是 6。

现在，我们就可以通过遍历 1 ~ 2<sup>n</sup>-1 的所有数字来寻找一个字的所有有效切片：

现在，幂字典中记录了每个切片分别对应哪个字根（或者不对应任何字根），由此我们可以正式进入一个字的拆分环节。

### 可行拆分集生成（`Sequential.__addSchemeList`）

在未开始拆分之前，我们将一个字的状态用 2<sup>n</sup>-1 表示，我们将它称为剩余数。每当我们从这个字上取下一个切片时，我们就将这个切片对应的数从剩余数中减去，得到新的剩余数。那么给定任意一个剩余数，我们如何知道从它身上能取下哪些切片呢？

首先，我们要引入一个限定原则（首笔序原则），即拆分得到的字根列表是按它们首笔笔顺排列的。因此，在每次从没有拆完的部分中取切片的过程中，必须取到该部分的第一笔。例如，第一次拆分时必须取到该字的第一笔。

所以，拆分算法可以概括为：

- 建立两个列表记录拆分状态，一个为未完成列表，一个为完成列表，向未完成列表中加入初始值 (2<sup>n</sup> - 1)，即将整个部件作为一个剩余数；
- 取未完成列表中的某个拆分，将它的最后一个数（即剩余数）经由 `nextRoot` 函数处理，得到所有可能切片，用幂字典检验它们的有效性，如果无效则予以剔除，有效则保留；
- 如果切片恰好等于剩余数，说明这个基本部件被拆完了，我们将它添加到已完成列表中；否则用剩余数减去新切片，将它添加到未完成列表中，形成堆栈；
- 重复上述过程，直到未完成列表全部被清空。

## 二分中间类（`core.dichotomous.Dichotomous`）

TODO

## 四角中间类（`core.tetragonal.Tetragonal`）

TODO
