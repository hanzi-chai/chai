拆分基本流程
=========================

概述
---------

在用户文档中，您了解到了如何构建自己的方案类，并结合配置文件输出码表。现在让我们来了解一下拆分过程背后的原理。汉字结构复杂多变，现有的各种编码方案对汉字的拆分方式也各不相同；提取出一个通用的逻辑来实现汉字的自动拆分似乎是很困难的事情。但是，在回顾现有的各种编码方案时，我们观察到了以下特点：

1. 绝大多数汉字根据其构字原理（例如形声构字、会意构字等）可以划分为多个部件，部件又可以划分为更小的部件，经过层层分解之后可以用七八百个基本部件以简单的几何关系组合而成。同时，绝大多数编码方案的字根数量在 200 ~ 400 之间，所以 **汉字拆分的实质是首先将基本部件拆分为字根，然后由基本部件的拆分推导出所有汉字的拆分**。
2. 绝大多数编码方案限制拆分以笔画为最小单位。由于基本部件的笔画数量少，我们可以枚举出他们所有可能的拆分方案；在得到所有可能的拆分方案后，我们再根据拆分规则选取最佳的拆分，就可以实现汉字自动拆分。

所以，本系统的实现方式就是：首先针对基本部件枚举所有可能的拆分方案，以拆分规则选取最佳拆分方案；然后用基本部件的拆分方案推导出所有汉字的拆分方案。

基本元素
-------------------------------------------

为了实现自动拆分，我们首先需要将汉字的信息，特别是基本部件的信息在计算机中进行合理的表示。让我们首先从笔画开始。

笔画
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在本系统中，**笔画** 表示为由一段或多段曲线顺次相接组成的几何图形。不同于字体文件，笔画在这里被认为是没有宽度的，对它的描述比较接近人们的书写直观，例如「横」就表示为一条直线段，「撇」可以表示为一条曲线段，而「横撇」则可以表示为一条直线段接上一条曲线段。直线段的具体数学形式是一次 Bezier 曲线（``base.Linear``），曲线段的具体数学形式是三次 Bezier 曲线（``base.Cubic``），它们具体的实现可参阅有关 API 文档。

国标规范将笔画分为 31 种，它们用曲线表示的具体方法请参见\ `数据库文档 <https://hanzi-chai.github.io/data/>`__\ 。

部件、复合体和汉字
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

在本系统中，**部件** 表示为由一个或多个笔画按一定顺序在给定位置上排布组成的几何图形。例如，部件「十」是由「横」和「竖」两个笔画在特定的位置上排布组成的部件，而这两个笔画分别由各自的直线段的参数确定。

当两个或以上的部件按一定的方位关系组合时，它们就形成了一个 **复合体**。例如，「口」和「巴」按左右关系组合成复合体「吧」，但按上下关系组合成复合体「邑」。为了准确地描述这种组合的特点，我们需要引入 **算符** 来表示这种关系。上面提到的左右关系的运算符为 ``h``，而上下关系的运算符为 ``z``。本项目共采用 12 个运算符，具体参见\ `数据库文档 <https://hanzi-chai.github.io/data/>`__\ 。复合体可以继续按各种运算符组合起来，形成更加复杂的复合体。为了描述方便起见，由一个运算符所组合起来的两个部件或复合体被称为这个运算符的 **算元**。

部件和复合体统称为 **汉字**。

字根
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**字根** 是所有汉字编码方案中用来编码的基本元素。考虑到本系统的实现方式，这里我们把字根分为 **部件字根** 和 **复合体字根**。以五笔字型编码方案为例，「大」是一个部件字根，它可以用于「天」等汉字的拆分；而「羽」则是一个复合体字根，可以用于「翼」等字的拆分。

``Chai`` 基类
---------------

在用户文档中我们看到，用户构建的方案类继承自各模板类，而所有模板类最终都是基类 ``Chai`` 的子类。基类的意义在于定义了大部分的类属性，并定义了进行自动拆分的步骤。当我们构建方案类 ``Input``、实例化得到 ``input`` 并执行 ``input()`` 时，调用的就是基类的 ``__call__()`` 方法：

.. code:: python

   def __call__(self) -> None:
       # 对部件进行拆分
       self.getComponentScheme()
       # 对复合字进行拆分
       self.getCompoundScheme()
       # 对汉字进行编码
       self.encode()
       # 把结果输出到文件
       ...

在一个高的层次上说，这几句话干了这些事情：

-  ``self.getComponentScheme()``：生成所有部件拆分，结果保存到
   ``self.COMPONENTS`` 的各个部件中；
-  ``self.getCompoundScheme()``：生成所有复合体拆分，结果保存到
   ``self.COMPOUNDS`` 的各个复合体中；
-  ``self.encode()``：生成所有给定字集中字的编码，保存到 ``self.COMPONENTS`` 或者 ``self.COMPOUNDS`` 中的相应对象中。

对部件进行拆分
-----------------

``self.getComponentScheme()`` 的内容如下：

.. code:: python

   def getComponentScheme(self) -> None:
       '''
       向所有 ``self.COMPONENTS`` 中的部件注入拆分方案
       '''
       for component: Component in self.COMPONENTS.values():
           component.scheme = self._getComponentScheme(component)

公有方法 ``getComponentScheme()`` 有一个同名的私有方法 ``_getComponentScheme()`` 与之对应，私有方法负责处理每一个部件的拆分，然后由公有方法调用私有方法进行汇总。但是基类不负责私有方法的实现，而是派发给各个模板类来实现。而 ``_getComponentScheme()`` 在逻辑上需要分为两个阶段来实现：

（1）生成所有可能的拆分方案
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

这一部分不同模板类实现的方式非常不同，故放在模板类中讨论。

（2）选择最优拆分方案
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如何从大量可能的拆分方案中选取最优的拆分方案？我们回顾了很多汉字编码方案，观察到了以下事实：

1. 绝大多数汉字编码方案会提出不止一条拆分规则，例如「取大优先」「能连不交」等等。我们认为它的实质是：所有可能的拆分方案首先经过第一条拆分规则检验，与该规则不符合的被筛去，剩余一定数量的拆分方案再经过第二条拆分规则检验，与该规则不符合的再被筛去，如此循环往复直到最后一条拆分规则执行完毕，此时应该有且仅有一个拆分方案被保留。
2. 我们认为每条拆分规则的实质是：每条规则可以表示为一个函数，这个函数的输入是拆分方案，输出是一个数值；在所有的拆分方案中，只有使这个函数取到最值的才能通过此轮筛查，其余将被筛去。例如，如果拆分规则是「根少优先」，当所有可能的拆分方案中最少的是 4 个字根时，所有大于等于 5 个字根的拆分方案都将在这一轮中筛去。对于最值而言，取最大值和取最小值是可以通过加个负号来互相转变的，所以我们可以统一定义为最小值。

我们形象地将每个这样的函数称为「筛（sieve）」。综上所述，一个典型的选取过程是这样的：

* 我们得到了 10 个拆分方案
* 「根少优先」：我们发现其中 3 个方案将字拆为 2 个字根，5 个方案将字拆为 3 个字根，2 个方案将字拆为 4 个字根。那么，筛去所有不为 2 个字根的拆分方案，剩余 3 个拆分方案；
* 「取大优先」：我们发现其中 2 个方案的第一个字根有 3 笔，另一个方案的第一个字根有 2 笔。那么，筛去第一个字根有 2 笔的拆分方案，剩余 2 个拆分方案；
* 「笔顺优先」：我们发现剩余的两个方案中第一个字根分别来自原部件的第 1, 2, 4 笔和第 1, 2, 3 笔，则后者更符合笔顺。由此我们得到了唯一的拆分方案。

拆分复合体
-------------------------------------------

.. code:: python

   def getCompoundScheme(self) -> None:
       '''
       向所有 ``self.COMPOUNDS`` 中的部件注入拆分方案
       '''
       for compound in self.COMPOUNDS.values():
           compound.scheme = self._getCompoundScheme(compound)

复合体的拆分遵守类似的逻辑，``_getCompoundScheme()`` 派发给模板类来实现。
