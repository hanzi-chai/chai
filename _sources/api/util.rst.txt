工具
===========================

「文」数据库预处理
------------------

基本部件是拆分算法所要处理的对象。处理过程中，我们可能需要用到许多种可能的信息，但任何信息都是可以基于图形信息推导得出的。因此，本系统仅存储最原始的数据，即「这个基本部件是怎么写出来的」。

具体而言，我们：

-  将基本部件表达为多个笔画；
-  将笔画表达为笔画类别和多个绘制命令；
-  每个绘制命令由绘制种类和绘制参数组成，具体可参见 Wiki
   页面中的「「文」数据库开发规范」。

.. code:: yaml

   一:
     - [横, [m, 25, 470], [h, 967]]
   丁:
     - [横, [m, 52, 130], [h, 918]]
     - [竖钩, [m, 508, 132], [v, 833]]

在程序中，为了实现上述数据的封装，每个笔画由一个 Stroke
对象表示，每个字由一个 Char
对象表示。当我们取一个字的其中一部分笔画构成一个新字时，我们称新字是源字的「切片」，切片也用一个
Char 对象表示。

「字」数据库预处理
------------------

所有不属于基本部件的汉字均以键值对的形式存储在 ``字.yaml``
中，其值为一个表达式。一个表达式由一个二元运算符和两个操作对象组成，例如：

.. code:: yaml

   他: [h, 亻, 也]

其中 ``h`` 为左右结构运算符，\ ``亻`` 和 ``也``
为操作对象。当没有合适的部件来表达一个操作对象的时候，值也可以是另一个表达式，例如：

.. code:: yaml

   前: [z, 前上, [h, 青下, 刂]]

在程序中，为了便于运算，我们定义了树类（\ ``Tree``\ ），将表达式处理为一个树对象。初始化该树对象时，我们不仅存储了该表达式的结构，还将每个值继续展开直到基本部件，例如：

.. code:: yaml

   价: [h, 亻, 介]

这里 ``亻`` 是基本部件，而 ``介`` 不是，它由 ``人`` 和 ``齐下``
两个更基本的部件组成。总而言之，\ ``Tree`` 对象以 ``name``
储存汉字名称，\ ``structure`` 存储结构运算符，\ ``first`` 和 ``second``
存储运算符的操作对象，这些对象仍然是一个 ``Tree``
对象，如此迭代展到直到基本部件，它的 ``first`` 和 ``second`` 值为
``None``\ ，也即基本部件是树的末端节点。

拓扑缓存（\ ``cache.topology``\ ）
----------------------------------

先考虑较简单的情况，两个由一条 Bezier
曲线构成的笔画之间的关系。此时我们首先解方程：

.. math::


   \boldsymbol b_i(t_i)=\boldsymbol b_j(t_j)

若求得这样的解，检验是否有 :math:`0\le t_i,t_j\le 1`\ 。

-  若无解，两笔画相离；
-  若有解，且 :math:`t_i,t_j` 中的一个约等于 0 或
   1，那么两笔画相接，一笔画的端位接到另一笔画的中间；
-  若有解，且 :math:`t_i,t_j` 都约等于 0 或
   1，那么两笔画相接，一笔画的端位接到另一笔画的端位；
-  若有解，且上述条件不满足，则两笔画相交。

在实践中，上述方程由 Newton 梯度下降法求解。
