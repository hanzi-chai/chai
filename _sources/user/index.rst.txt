欢迎使用汉字自动拆分系统「拆」！

本文档分为用户文档和开发者文档两部分，您可以首先阅读用户文档，如果对其中具体的实现细节感兴趣，再进一步了解开发者文档。

用户文档
========

一、安装
--------

您可以在 PyPI 上下载汉字自动拆分系统：

.. code:: bash

   pip3 install pychai

该系统依赖
PyYAML，如您尚未安装，将在安装「拆」时自动安装。您也可以通过命令
``pip3 install PyYAML`` 手动安装。

二、配置文件编写
----------------

由于本系统的高度模块化特性，您可以通过编写简单的配置文件的方式来指定一个输入方案的绝大部分信息。让我们以
98 五笔 ``wubi98.schema.yaml`` 为例进行解说。

1 获取示例
~~~~~~~~~~

您可以用两行简单的程序将本系统的预置方案的配置文件和编码程序调用出来。例如，您可以编写

.. code:: python

   from pychai import example
   example('wubi98')

这会将 ``wubi98.schema.yaml`` 拷贝到您的当前工作目录下。一同拷贝的还有
``wubi98.py``\ ，它是适用于该方案的编码程序，我们现阶段还暂时用不到。

除了传入参数 ``wubi98`` 之外，您也可以传入
``fingertip``\ （一个二分风格形码方案）或
``xiaoqing``\ （一个二笔方案）来获得相应的文件。

2 理解 ``schema``
~~~~~~~~~~~~~~~~~

配置文件的第一部分是方案基本信息。这一部分不会对方案的制作产生影响，但出于方便交流考虑，建议您留下您的个人信息。例如：

.. code:: yaml

   schema:
     name: 五笔字型 98 版
     version: "0.1"
     author:
       - 发明人 王永民
       - 重建人 蓝落萧 2320693692@qq.com
     description: |
       用于测试自动拆分

--------------

下面我们来指定方案的拆分规则。

3 理解 ``degenerator``
~~~~~~~~~~~~~~~~~~~~~~

``degenerator``
者，中文名曰「退化映射」也。退化映射是本系统最重要的概念，没有之一。这是因为：「拆」的数据库中精确存储了汉字的图形信息，退化映射决定了您希望不同的图形在何种程度上可以被视为同一个字根。例如：

.. code:: yaml

   degenerator:
     - 笔画序列
     - 笔画拓扑

笔画序列的含义是，当待拆分的汉字中含有与给定字根相同的笔画顺序时，我们才能够从该字中拆出给定的字根。例如，对于「月」字根，「用」字中包含该字根，而「青」字中不含有该字根，因为「青」的下部第一笔为「竖」。

笔画拓扑的含义是，在笔画序列的基础上，我们还要进一步考虑笔画之间的关系。例如，「工」和「土」具有完全相同的笔画序列，但「土」的第一二笔为相交关系，「工」为相连关系，它们并不相同。添加「笔画拓扑」之后，这种情况就能够得以区分。

目前，我们仅预设了这两个组件，如果您希望指定更细致的退化映射，请您了解开发者文档并进行相关算法的编写。

4 理解 ``selector``
~~~~~~~~~~~~~~~~~~~

``selector`` 者，中文名曰「择优函数」也。经过 ``degenerator``
处理后，我们得到了汉字的多种可能拆分方式。此时，我们根据一系列规则确定选取哪种拆分方式。例如：

.. code:: yaml

   selector:
     - 根少优先
     - 笔顺优先
     - 能连不交、能散不连
     - 取大优先

-  根少优先，即拆出的字根数应该尽量少。
-  笔顺优先，即拆分应该尽可能符合笔顺。
-  能连不交、能散不连，即拆出的字根应该尽量为「散」关系，其次为「连」关系，最次为「交」关系。
-  取大优先，即拆分出的字根排在前面的笔画应该尽量多。

同样，我们目前仅预设了这四个组件，如果您希望指定更细致的择优函数，请您了解开发者文档并进行相关算法的编写。

值得注意的是，\ ``degenerator`` 各组件的顺序对拆分结果无影响，但
``selector``
各组件的顺序对拆分结果有影响。作为实例，请考虑「平」的拆分：给定字根「一、丷、十、干」，若组件的顺序如上，则拆为「干、丷」；若「笔顺优先」调整到最前面，则拆为「一、丷、十」。

那么，我们如何确定我们给出的规则一定能确定唯一的拆分方式呢？对于这个问题我们没有一般的回答，但可以证明，当「笔顺优先」和「取大优先」均出现（不管顺序如何，也不管有什么其他的组件）时，能确定唯一的拆分方式。因此，如果您没有详细地考虑过其余选择方案的唯一性，建议保证包含这两者。

拆分规则至此结束，下面我们来指定方案的字根。

--------------

5 理解 ``classifier``
~~~~~~~~~~~~~~~~~~~~~

我们注意到，许多方案将汉字的笔画进行了分类，这使得作者和用户可以笼统地掌握笔画而不用掌握每一种情况。在国家标准黑体类字形中，笔画共有
31 种，但绝大多数方案将它们分为 5 至 7
类。最流行的划分方案是国家标准、五笔、二笔等采用的五分法：

.. code:: yaml

   classifier:
     1: [横, 提]
     2: [竖, 竖钩]
     3: [撇]
     4: [点, 捺]
     5: [横钩, 横撇, 横折, 横折钩, 横斜钩, 横折提, 横折折, 横折弯, 横撇弯钩, 横折弯钩, 横折折撇, 横折折折, 横折折折钩,
         竖提, 竖折, 竖弯, 竖弯钩, 竖折撇, 竖折折钩, 竖折折,
         撇点, 撇折, 弯钩, 斜钩]

进行分类意味着同一类中的笔画将放置在相同的键位上。

6 理解 ``mapper``
~~~~~~~~~~~~~~~~~

在这一步，我们将字根映射到指定的键位上。例如：

.. code:: yaml

   mapper:
     g: [1, 11, 王, 青上, 五, 夫, 夫上, 举下, 年下, 舛右]
     ...
     x: [幺, 双折, 纟, 母, 彖上, 贯上, 弓, 匕, 化右, 比左]

这里「键位」不一定需要为实体按键，也可以是虚拟的键名。作为实例，请参考
``fingertip.schema.yaml``\ 。

7 理解 ``aliaser``
~~~~~~~~~~~~~~~~~~

您可能已经注意到了：在 ``mapper`` 中，字根分为两类：

-  一类为单个字符，如「王」；
-  一类为多个字符，如「年下」；

单个字符所描述的字根就是它本身，而多个字符所描述的字根是非成字字根，可以任意命名。那么，我们何从知道多个字符描述的具体是什么字根呢？这就需要通过「别名注册器」进行注册：

.. code:: yaml

   aliaser:
     ...
     夫上: [夫, [0, 1, 2]]
     ...

这里，我们指定「夫上」是由源字「夫」的第 0 笔至第 2
笔构成的字根（\ **请注意：这里从 0 开始计数！字的笔画为第 0 笔、第 1
笔、……**\ ）。这样，系统通过结合图形数据，即可知道「夫上」的形状如何了。

请注意，别名注册器所接受的源字必须是一个基本部件，否则将无法识别。为了防止生成码表时出现错误，您可以先用我们提供的测试工具进行测试：

.. code:: python

   from pychai import lookup
   lookup('夫', [0, 1, 2])

此时有可能出现三种情况。本例中「夫」是一个基本部件，所以返回成功信息：

::

   恭喜！您现在可以为该字根起一个名字，在 mapper 中添加这个字根的名字，并在 aliaser 中注册，语法如下：
   【名字】: [夫, [0, 1, 2]]

但如果您使用的源字是「规」，虽然规的前三笔也是夫的前三笔，但是它会提示：

::

   提供的汉字「规」不是基本部件，它的结构为：[h, 夫, 见]。请尝试将您需要的字根定位到这些基本部件中，然后重新查询。

这表明您必须先将字根定位到基本部件中才能进行查询。最后，如果您提供的是一个非
GB 汉字，则本系统无法帮您查询，将提示「您提供的汉字「X」不在 GB
字集内。请您使用常用汉字查询字根。」。

不过，在查看 ``wubi98.schema.yaml``
时，您可能注意到，有一部分多个字符描述的字根无需注册。这是因为，这些名称已经是数据库中存储基本部件时使用的名称。您可以参考该方案的
``mapper`` 模块找出您所需要的名称，如果没有发现再进行定义。

三、码表输出
------------

然而，仅仅编写配置文件并不能满足每个人对于取码编码的不同需求。因此，本系统仍然要求使用者编写一定量的代码（小于五十行）来自定义编码工作。下面我们就来看一下在拆分结束后用户如何取码。

1 读入方案
~~~~~~~~~~

安装好 ``Chai.py`` 后，我们需要在自己的文件中导入 ``Schema``
类，用它读入自己的方案（这里以 ``wubi98`` 为例），运行拆分：

.. code:: python

   from Chai import Schema

   wubi98 = Schema('wubi98')
   wubi98.run()

当 ``Schema('wubi98')``
执行时，系统会首先查看当前文件夹（也就是这行语句所在的程序所在的文件夹）是否含有
``wubi98.schema.yaml``\ ，如果没有，则在内置文件夹中寻找。由于
``Schema`` 是一个类，这个操作相当于实例化一个 ``Schema``
对象，我们将其命名为 ``wubi98``\ 。

然后，\ ``wubi98.run()``
则代表的是根据配置文件中所包含的拆分规则和字根选取运行拆分。取决于您的字集大小和拆分规则，这一过程可能会耗时
5 至 10 秒。

2 ``Schema.component`` 属性
~~~~~~~~~~~~~~~~~~~~~~~~~~~

运行结束后，\ ``wubi98`` 对象将会生成一个 ``wubi98.component``
属性，它的结构如下：

.. code:: python

   {
       nameChar1: (objectRoot1, objectRoot2, ...),
       ...
   }

其中，\ ``nameChar`` 是「名义字」，即一个字符串，如 ``'的'``\ 。而
``objectRoot1, ...`` 则是「对象字根」，它们是自定义类 ``Char``
的实例。我们接下来就会看到如何利用这些 ``Char`` 类对象进行编码。

但在这之前，我们有必要提醒读者：\ ``wubi98.run()``
并没有生成所有字的拆分，而是生成了所有「基本部件」的拆分。例如「里」是一个基本部件，它是
``wubi98.component`` 的键之一，但「理」、「锂」等并不在
``wubi98.component`` 中。它们的拆法由下面给出的办法定义：

3 ``Schema.tree`` 属性
~~~~~~~~~~~~~~~~~~~~~~

例如，\ ``wubi98.tree`` 的结构如下：

.. code:: python

   {
       nameChar1: tree1
       ...
   }

其中 ``nameChar`` 和上面相同，而 ``tree`` 则是一个自定义类 ``Tree``
的实例。\ ``Tree`` 具有如下属性：

-  ``Tree.name``\ ：字名，例如「理」；
-  ``Tree.structure``\ ：字的结构，例如「理」为左右结构，代码为
   ``h``\ ；
-  ``Tree.first`` 和
   ``Tree.second``\ ：字按该结构进行二分之后，得到的第一部分（如王）和第二部分（如里）。

注意，这些部分仍然是一个 ``Tree``
对象，如此不断迭代拆分，直到不可再分（即某一部分为基本部件）为止，此时基本部件对应的
``Tree`` 的 ``first`` 和 ``second`` 属性均为 ``None``\ ，其结构为空。

4 顺序风格编码示例
~~~~~~~~~~~~~~~~~~

这里，「顺序风格」指的是类似于五笔的顺序取字根的方式。此时，基本部件按顺序拆分，而其他字先表示为基本部件的序列，然后依次取各个部件的拆分，再合并到一起。这种取码方式用代码表达就是：

.. code:: python

   for nameChar in wubi98.charList:
       if nameChar in wubi98.component:
           scheme = wubi98.component[nameChar]
       else:
           tree = wubi98.tree[nameChar]
           componentList = tree.flatten()
           scheme = sum((wubi98.component[component] for component in componentList), tuple())

在这里，我们获得合体字的树后，将其打平（\ ``Tree.flatten()``\ ）为基本部件的列表，它不含有任何嵌套；然后再将各个基本部件的拆分连接起来。显然此时
``scheme`` 是一个含有若干「对象字根」的元组。然后：

.. code:: python

   code = ''.join(wubi98.rootSet[objectRoot.name] for objectRoot in scheme)

这里表示，我们取每个对象字根的名字（实际上此时变成了名义字根），然后用
``wubi98.rootSet`` 转为编码，就完成了编码。

当然，实际的规则要略为复杂一些，例如我们如何对字根字进行编码呢？假设普通字根字的编码规则为：字根所在键位
+ 第一、二、末笔。那么我们可以写：

.. code:: python

   if len(scheme) == 1:
       objectRoot = scheme[0]
       nameRoot = objectRoot.name
       firstStroke = objectRoot.strokeList[0].type
       secondStroke = objectRoot.strokeList[1].type
       lastStroke = objectRoot.strokeList[-1].type
       info = [nameRoot, firstStroke, secondStroke, lastStroke]
       code = ''.join(wubi98.rootSet[nameRoot] for nameRoot in info)

哈！原来一个对象字根（\ ``objectRoot``\ ）不仅有名字属性，还有「笔画序列」（\ ``strokeList``\ ）属性。例如，\ ``objectRoot.strokeList[0]``
就取到了该字的第一笔。每一笔都是一个 ``Stroke`` 对象，它具有一个
``type`` 属性，如「横」，我们将它用 ``rootSet``
进行映射，就得到了字根字的编码。

本系统还能轻而易举地完成识别码的添加。具体细节请看 GitHub 仓库中的
``wubi98.py``\ 。

5 二分风格编码示例
~~~~~~~~~~~~~~~~~~

待续。

6 二笔类编码示例
~~~~~~~~~~~~~~~~

待续。

开发者文档
==========

如果您认真阅读了用户文档，一定会对汉字自动拆分的实现感到惊奇。的确，汉字的形状变化万千，各种编码方案对其的拆分也各不相同，数不胜数，异常复杂。

然而，汉字的可能拆分方式是无穷无尽的吗？我们知道，汉字的笔画数量是有限的，如果我们限制拆分以笔画为最小单位，拆出的字根中每个字根至少包含一个笔画，则汉字的可能拆分方式的数量必然是一个有限大——尽管确实很大——的数。枚举出有限多的拆分方式中，我们再根据确定的规则自动化选取最佳的拆分，就实现了汉字自动拆分。本系统之所以可行，正是基于如此简单的原理。

那么汉字的可能拆分数量大约有多大呢？经过简单的计算，它大约略小于笔画数量的阶乘。一个十笔的字有数十万种拆分，而一个二十笔的字的拆分数量已经超出了任何计算机所能存储的极限。因而如上原理的直接应用又是不可能的。

所幸，基于汉字作为表意文字的特性，绝大多数汉字内在地划分成多个部件（例如形声字、会意字等），部件又可以划分为更小的部件，经过逐级分解之后可以用六七百个基本部件以简单的几何关系组合而成。而对于绝大多数的形码而言，字根数量不过二三百个，所进行的拆分也基本上是针对基本部件的拆分，极少出现一个字根横跨两个基本部件的情况。因此我们引入了本系统最重要的一个假设：

   分部假设：含有多个部件的汉字的拆分结果，可以近似地由每个部件的拆分结果，以及这些部件相互组合的几何关系决定。

基本部件的笔画数量少，因而对它们进行枚举是可以做到的。由此我们引出了本系统的顶层架构：

1. 基本部件拆分为字根：由于不同编码方案天差地别，为了最大程度满足它们的需求，我们针对基本部件枚举所有可能的拆分，然后以拆分规则筛选出唯一的拆分；
2. 用基本部件确定其他汉字：将其他汉字表示为由基本部件构成的树状结构；
3. 根据「基本部件的拆分」和「其他汉字的树状结构」进行编码。
